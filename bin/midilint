#!/usr/bin/env python3
import sys
import argparse
from pathlib import Path
from typing import Callable

import mido
import midi_abstraction as mab

import midilint


def main(source: Path, args) -> None:
    """
    Parse source, manipulate, save to dest.
    """
    mid = mido.MidiFile(source, clip=True)


    # Identify then exit
    if args.identify:
        for k, v in midilint.identify(mid).items():
            print(f"{k:<20} {v}")
        return

    # normalize
    if args.velocity is not None:
        mid = midilint.normalize(mid, args.velocity)

    # pitch correction
    if args.key is not None:
        note, mode = args.key.split("_")
        notes = getattr(mab, mode.upper()).notes(note)
        mid = midilint.correct_pitch(mid, notes)

    # note alignment
    if args.align:
        mid = midilint.align(mid, args.precision)

    # Save to dest if it was provided, otherwise
    # overwrite input file.
    if args.DEST is not None:
        mid.save(args.DEST)
    else:
        mid.save(source)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog=f"{Path(__file__).name}",
        description="The midi linter.",
    )

    parser.add_argument("SOURCE", type=Path, help="the midi file to lint")

    parser.add_argument(
        "DEST",
        type=Path,
        help="the name of the output file",
        nargs="?",
    )

    parser.add_argument("--velocity", type=int, help="the velocity to set all notes to")

    parser.add_argument(
        "--key", type=str, help="the key to snap notes to. E.g. c_major or e_phrygian."
    )

    parser.add_argument(
        "--align",
        action="store_true",
        help="align the start and end of notes to intervals",
    )

    parser.add_argument(
        "--precision",
        type=int,
        default=1,
        help="determines the size of the interval to align to. 1 is quarter note, 2 is eighth, 4 is sixteenth, etc",
    )

    parser.add_argument(
        "--identify",
        action="store_true",
        help="read information about a file"
    )

    args = parser.parse_args()

    # Raise FileNotFoundError if SOURCE doesn't exist.
    args.SOURCE.resolve()

    # Ensure DEST doesn't already exist.
    if args.DEST is not None:
        if args.DEST.absolute().exists():
            raise FileExistsError(args.DEST)

    # Validate that velocity is 0-127.
    if args.velocity is not None:
        if args.velocity < 0 or args.velocity > 127:
            raise ValueError(
                f"velocity was {args.velocity} but must be between 0 and 127 (inclusive)"
            )

    # Validate key
    if args.key is not None:
        keys = []
        for n in list(mab.Note):
            for m in list(mab.Mode):
                keys.append(f"{n.value}_{m.value}")
        if args.key not in keys:
            raise ValueError(
                f"key was {args.key} but must be one of:\n{'\n'.join(keys)}"
            )

    source = args.SOURCE.absolute()
    main(source, args)
