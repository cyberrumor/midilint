#!/usr/bin/env python3
import sys
import argparse
from pathlib import Path
from typing import Callable

import mido
import midi_abstraction

import midilint


def main(source: Path, dest: Path, args) -> None:
    """
    Parse source, manipulate, save to dest.
    """
    mid = mido.MidiFile(source, clip=True)

    # normalize
    if args.velocity is not None:
        mid = midilint.normalize(mid, args.velocity)

    # pitch correction
    if args.key is not None:
        strats = {
            "up": shift_up,
            "down": shift_down,
            "nearest": shift_nearest,
        }
        key = midi_abstraction.Key(args.key)
        mid = midilint.correct_pitch(mid, key, strats[args.strategy])

    # note alignment
    if args.align:
        mid = midilint.align(mid, args.precision)

    mid.save(dest)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog=f"{Path(__file__).name}",
        description="Read SOURCE midi file and save processed version to DEST",
    )

    parser.add_argument("SOURCE", type=Path, help="the midi file to lint")

    parser.add_argument("DEST", type=Path, help="the name of the output file")

    parser.add_argument("--velocity", type=int, help="the velocity to set all notes to")

    parser.add_argument(
        "--key", type=str, help="the key to snap notes to. E.g. c_major or e_phrygian."
    )

    parser.add_argument(
        "--strategy",
        type=str,
        default="nearest",
        help="note snapping algorithm. 'up', 'down', or 'nearest'",
    )

    parser.add_argument(
        "--align",
        action="store_true",
        help="align the start and end of notes to intervals"
    )

    parser.add_argument(
        "--precision",
        type=int,
        default=1,
        help="determines the size of the interval to align to. 1 is quarter note, 2 is eighth, 4 is sixteenth, etc"
    )

    args = parser.parse_args()

    # Raise FileNotFoundError if SOURCE doesn't exist.
    args.SOURCE.resolve()

    # Ensure DEST doesn't already exist.
    if args.DEST.absolute().exists():
        raise FileExistsError(args.DEST)

    # Validate that velocity is 0-127.
    if args.velocity is not None:
        if args.velocity < 0 or args.velocity > 127:
            raise ValueError(
                f"velocity was {args.velocity} but must be between 0 and 127 (inclusive)"
            )

    # Validate key
    if args.key is not None:
        keys = []
        for n in midi_abstraction.list_notes():
            for m in midi_abstraction.list_modes():
                keys.append(f"{n}_{m}")
        if args.key not in keys:
            raise ValueError(
                f"key was {args.key} but must be one of:\n{'\n'.join(keys)}"
            )

        # If a key was passed, we need to validate the strategy.
        assert args.strategy in [
            "up",
            "down",
            "nearest",
        ], f"strategy was {args.strategy} but must be one of 'up', 'down', or 'nearest'."

    source = args.SOURCE.absolute()
    dest = args.DEST.absolute()
    main(source, dest, args)
